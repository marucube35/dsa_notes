<!DOCTYPE html>
<html>

<head>
  <title>Searching.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="../main.css">
<div class="bg">
     <center><h1 class="bigtitle">Hash Table</h1></center>
</div>
<h1 id="searching-algorithms">Searching Algorithms</h1>
<p><strong>Không gian tìm kiếm</strong></p>
<p>Là đối tượng mà thuật toán tìm kiếm thực hiện lên, thường là mảng, đoạn giá trị nào đó, danh sách liên kết, cây,...</p>
<p><strong>Điều kiện tìm kiếm</strong></p>
<p>Là tiêu chuẩn tìm kiếm trình bày dưới dạng phát biểu không hình thức và lập trình viên cần hình thức hóa nó thành một biểu thức logic.</p>
<h1 id="linear-search">Linear Search</h1>
<h2 id="idea">Idea</h2>
<p>Duyệt toàn bộ danh sách A để xác định phần tử $a_i$ cần tìm và trả về vị trí i của nó.</p>
<h2 id="input---output">Input - Output</h2>
<ul>
<li><strong>Input</strong> : Danh sách A có n phần tử, giá trị khóa x cần tìm.</li>
<li><strong>Output</strong> : Chỉ số i của phần tử $a _i$ trong A có giá trị khóa là x.</li>
</ul>
<h2 id="complexity">Complexity</h2>
<ul>
<li><strong>Best case</strong> : $a_0$ chứa khóa x - số lần lặp lại là 1 - độ phức tạp hằng số $O(1)$.</li>
<li><strong>Worst case</strong> : A không chứa phần tử có khóa x - số lần lặp là n - độ phức tạp tuyến tính $O(n)$.</li>
<li><strong>Average case</strong> : Độ phức tạp tuyến tính $O(n)$.</li>
</ul>
<h2 id="note">Note</h2>
<p>Linear Search sẽ duyệt toàn bộ không gian tìm kiếm nên các đối tượng tìm kiếm không cần được sắp xếp, có thể nói là dữ liệu không cần được tổ chức.</p>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">linearSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++){

        <span class="hljs-keyword">if</span>(a[i] == x){

            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</div></code></pre>
<h1 id="binary-search">Binary Search</h1>
<h2 id="idea">Idea</h2>
<p>Chọn $a_M$ ở giữa A để so sánh với khóa x. A được chia thành hai phần trước và sau $a_M$. Chỉ số bắt đầu và kết thúc của A là L và R.</p>
<p>M = $\frac{L + R}{2}$, làm tròn phần nguyên.</p>
<p>So sánh x và $a_M$:</p>
<ul>
<li>Nếu x &lt; $a_M$, thì tìm x trong đoạn bên trái $a_M$.</li>
<li>Ngược lại thì tìm x trong đoạn bên phải $a_M$.</li>
<li>Nếu x = $a_M$ tức là đã tìm thấy và dừng thuật toán.</li>
</ul>
<p>Mảng giảm dần thì làm ngược lại.</p>
<h2 id="input---output">Input - Output</h2>
<ul>
<li><strong>Input</strong> : Danh sách A có n phần tử đã sắp xếp theo thứ tự <em>P</em> (tăng dần hoặc giảm dần), giá trị khóa x cần tìm.</li>
<li><strong>Output</strong> : Chỉ số i của phần tử $a_i$ trong A có giá trị khóa là x. Không tìm thấy trả về i = -1.</li>
</ul>
<h2 id="complexity">Complexity</h2>
<ul>
<li><strong>Best case</strong> : Phần tử cần tìm nằm ở vị trí (L + R)/2 – Số lần lặp là 1 – Độ phức tạp hằng số $O(1)$.</li>
<li><strong>Worst case</strong> : Số lần tìm là số lần chia đôi đến khi dãy tìm kiếm còn 1 phần tử - Lặp khoảng $log_2(n) + 1$ lần – Độ phức tạp logarithm $O(log_2(n))$.</li>
<li><strong>Average case</strong> : Độ phức tạp là $O(log_2(n))$.</li>
</ul>
<h2 id="note">Note</h2>
<p>Điều kiện tìm kiếm là không gian tìm kiếm phải được sắp xếp theo một thứ tự nào đó và ta sẽ dựa theo thứ tự này để tìm kiếm.</p>
<h2 id="code">Code</h2>
<p><strong>Đệ quy</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">if</span> (left &gt; right)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span> (x == a[mid])
        <span class="hljs-keyword">return</span> mid;
    <span class="hljs-keyword">if</span> (x &lt; a[mid])
        <span class="hljs-keyword">return</span> binarySearch(a, left, mid - <span class="hljs-number">1</span>, x);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> binarySearch(a, mid + <span class="hljs-number">1</span>, right, x);
}
</div></code></pre>
<p><strong>Khử đệ quy</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>,R = n - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(L &lt;= R)
    {
        <span class="hljs-keyword">int</span> M = (L + R) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(x == a[M])

            <span class="hljs-keyword">return</span> M;
        <span class="hljs-keyword">if</span>(x &gt; a[M]){

            R = M - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>{
            L = M + <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</div></code></pre>
<h1 id="interpolation-search">Interpolation Search</h1>
<h2 id="idea">Idea</h2>
<p>Thay vì xác định điểm M = (L+R)/2 thì xác định M như sau:</p>
<p>$$
M =  L+\frac {(R - L)(x-A[L])}{ A[R]-A[L]}
$$</p>
<p>Các bước còn lại như Binary Search. Đây là một phương pháp trong xác suất thống kê, bởi vì vậy nên nó mới áp dụng cho phân bố dữ liệu ngẫu nhiên đồng đều.</p>
<h2 id="input---output">Input - Output</h2>
<p><strong>Input</strong> : Danh sách A có n phần tử đã có thứ tự <em>P</em> (tăng dần hoặc giảm dần), giá trị x cần tìm.</p>
<p><strong>Output</strong> : Chỉ số i của phần tử $a_i$ trong A có giá trị khóa là x. Không tìm thấy trả về i = -1.</p>
<h2 id="complexity">Complexity</h2>
<ul>
<li><strong>Best case</strong> : Tương tự Binary Search khi mà $a_M = x$ thì số lần lặp là 1, độ phức tạp sẽ là hằng số $O(1)$.</li>
<li><strong>Worst case</strong> : Trong trường hợp giá trị số của khóa tăng theo cấp số nhân thì độ phức tạp là $O(n)$.</li>
<li><strong>Average case</strong> : Nếu như dữ liệu được phân bố liên tục thì độ phức tạp sẽ là $log_2(log_2(n))$.</li>
</ul>
<h2 id="note">Note</h2>
<p>Thuật toán Interpolation Search áp dụng trong trường hợp không gian tìm kiếm đã được tổ chức theo một thứ tự (tăng dần hoặc giảm dần) và khóa cần tìm được phân bố liên tục trong không gian tìm kiếm (rải đều).</p>
<h2 id="code">Code</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpolationSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>, R = n - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(L &lt;= R) {
        <span class="hljs-keyword">int</span> M = L + (R - L)*((x - a[L])/(a[R] - a[L]));
        <span class="hljs-keyword">if</span>(x == a[M]){
            <span class="hljs-keyword">return</span> M;
        }
        <span class="hljs-keyword">if</span>(x &gt; a[M]){
            R = M - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>{
            L = M + <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</div></code></pre>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>