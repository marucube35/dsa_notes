<!DOCTYPE html>
<html>

<head>
  <title>avl.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="../../main.css">
<div class="bg">
      <center><h1 class="bigtitle">AVL Tree</h1></center>
</div>
<h1 id="definition">Definition</h1>
<p>Cây AVL là cây nhị phân tìm kiếm tự cân bằng có tính chất sau:</p>
<blockquote>
<p>Với mọi node, sự khác biệt chiều cao của cây con phải và cây con trái của node đó không vượt quá 1.</p>
</blockquote>
<p>Nói cách khác, khi xét tại node i nào đó, nếu chênh lệch độ cao hai cây con của node đó là -1, 0 hoặc 1 thì node đó cân bằng. Các trường hợp còn lại đều là không cân bằng và cần được cân bằng.</p>
<img src="img/Tree23.png">
<p>Do tính chất cân bằng này mà chúng ta có thể kiểm soát chiều cao của cây (nhị phân) tìm kiếm tốt hơn, phục vụ cho các thao tác liên quan.</p>
<h1 id="properties">Properties</h1>
<p>Gọi <code>N</code> là số node và <code>H</code> là chiều cao của cây AVL, ta có:</p>
<ul>
<li>Nếu có $N$ node trong cây, chiều cao tối thiểu là
$$
H_{min} = int(log_2(n + 1))
$$</li>
<li>Nếu có $N$ node trong cây, chiều cao tối đa là
$$
H_{max} = log_2(n).\sqrt2
$$</li>
<li>Nếu chiều cao của cây AVL là $H$, thì số node tối đa mà cây có là
$$
N \leq 2^H - 1
$$</li>
<li>Nếu chiều cao của cây AVL là H, thì số node ít nhất của cây được biểu diễn như sau:
$$
N(H) = N(H - 1) + N(H - 2) + 1\ \textrm{với }  N &gt; 2\
N(0) = 1\ \textrm{và } \ N(1) = 2
$$</li>
</ul>
<p>Ví dụ về cây AVL:</p>
<img src="img/Tree29.png">
<h1 id="rotation">Rotation</h1>
<p>BST có hai thao tác quan trọng là xoay cây trái và phải. Nếu ta xoay cây theo chiều bất kỳ, rồi xoay cây theo chiều ngược lại, thì ta sẽ được một cây nhị phân tìm kiếm như ban đầu. Chẳng hạn nếu xoay trái, rồi xoay phải, cây sẽ không đối.</p>
<p>Thuật toán xoay cây là một thuật toán local, nó chỉ thao tác xung quanh một node nào đó và các node con của nó, chứ không ảnh hưởng đến parent hoặc sibling của nó. Vì tính chất này mà Rotation mới giữ được tính chất của BST sau khi xoay cây.</p>
<p>Để cân bằng cây AVL thì ta sử dụng các thuật toán xoay cây nhằm giảm chiều cao của cây nhưng vẫn duy trì được tính chất BST của cây.</p>
<h2 id="left-rotation">Left Rotation</h2>
<p>Thuật toán xoay cây trái sẽ bắt đầu quanh một node nào đó. Chúng ta sẽ xét thêm cả node con phải của node đó. Ta gọi node đang xét là X, và node con phải là Y.</p>
<img src="img/Tree19.png">
<p>Nhiệm vụ của chúng ta là:</p>
<ul>
<li>Đẩy Y lên vị trí của X.</li>
<li>X trở thành con trái của Y.</li>
<li>Con trái của Y nếu có ($\beta$), sẽ là con phải của X. Vẫn duy trì được tính chất BST, do
$$
X &lt; \beta &lt; Y
$ành - Con phải của Y ($\gamma$) và con trái của X ($\alpha$) không đổi.
$$</li>
</ul>
<img src="img/Tree20.png">
<blockquote>
<p>Điều kiện của phép xoay trái là node cần xoay phải có con phải.</p>
</blockquote>
<p><strong>Code:</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LR</span><span class="hljs-params">(NODE *&amp;pRoot)</span>
</span>{
    <span class="hljs-comment">// Lưu tạm con phải (Y)</span>
    NODE *temp = pRoot-&gt;right;

    <span class="hljs-comment">// Con phải của X là con trái của Y (beta)</span>
    pRoot-&gt;right = temp-&gt;left;

    <span class="hljs-comment">// Con trái của Y trở thành X</span>
    temp-&gt;left = pRoot;

    <span class="hljs-comment">// Y thành X</span>
    pRoot = temp;
}
</div></code></pre>
<h2 id="right-rotation">Right Rotation</h2>
<p>Để xoay phải cây ta cũng xét tương tự xoay trái tại một node nào đó. Và ta sẽ xét thêm node con trái của node cần xoay. Ta gọi node đang xét là X và node con trái là Y.</p>
<img src = "img/Tree21.png">
<p>Tương tự phép xoay trái, ta cần:</p>
<ul>
<li>Đẩy X lên vị trí của Y.</li>
<li>Y trở thành con phải của X.</li>
<li>Con phải của X nếu có ($\alpha$) sẽ trở thành con trái của Y. Vẫn duy trì tính chất BST vì:
$$
X &lt; \beta &lt; Y
$$</li>
<li>Con trái của X ($\gamma$) và con phải của Y ($\alpha$) không đổi.</li>
</ul>
<img src ="img/Tree22.png">
<blockquote>
<p>Điều kiện của phép xoay phải là node cần xoay phải có con trái.</p>
</blockquote>
<p><strong>Code:</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RR</span><span class="hljs-params">(NODE *&amp;pRoot)</span>
</span>{
    <span class="hljs-comment">// Lưu tạm con trái (X)</span>
    NODE *temp = pRoot-&gt;left;

    <span class="hljs-comment">// Con trái của Y là con phải của X (beta)</span>
    pRoot-&gt;left = temp-&gt;right;

    <span class="hljs-comment">// Con trái của X thành Y</span>
    temp-&gt;right = pRoot;

    <span class="hljs-comment">// X thành Y</span>
    pRoot = temp;
}
</div></code></pre>
<p>Độ phức tạp của các thuật toán xoay cây là $O(1)$.</p>
<h1 id="unbalanced-cases">Unbalanced Cases</h1>
<p>Các trường hợp mất cân bằng, gồm:</p>
<h2 id="left-left-case">Left left case</h2>
<img src="img/Tree24.png">
<p>Để cân bằng cây, ta cần xoay phải tại node bị mất cân bằng, cụ thể là node 8.</p>
<h2 id="right-right-case">Right Right case</h2>
<img src="img/Tree26.png">
<p>Ngược lại với trường hợp left left, ta chỉ cần xoay trái cây tại node bị mất cân bằng, cụ thể là node 18.</p>
<h2 id="left-right-case">Left Right case</h2>
<img src="img/Tree25.png">
<p>Ta cần chuyển nó về trường hợp left left rồi xử lý theo trường hợp đó. Nói cách khác, xoay trái tại node con của node bị mất cân bằng. Rồi xoay phải tại node bị mất cân bằng. Cụ thể là xoay trái ở node 5 và xoay phải ở node 8.</p>
<h2 id="right-left-case">Right left case</h2>
<img src="img/Tree27.png">
<p>Tương tự như left right, ta cần chuyển nó về trường hợp right right rồi xử lý theo trường hợp đó. Cụ thể là xoay phải ở node 22 để thành right right. Sau đó xoay trái ở node 18 để cân bằng.</p>
<h2 id="examples">Examples</h2>
<p>Cho ví dụ một cây nhị phân tìm kiếm dưới đây, ta thấy cây mất cân bằng ở node 32 theo trường hợp phải trái. Lý do là vì 32 có con phải bị lệch, và con phải đó lại bị lệch sang trái. Để cân bằng cây, đầu tiên ta xoay phải ở node 49 rồi tiến hành xoay trái ở node 32.</p>
<img src="img/Tree28.png">
<p><strong>Code cân bằng cây:</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">balanceTree</span><span class="hljs-params">(NODE *&amp;pRoot)</span>
</span>{
    <span class="hljs-comment">// Đếm chiều cao của các cây con</span>
    <span class="hljs-keyword">int</span> hl = Height(pRoot-&gt;left);
    <span class="hljs-keyword">int</span> hr = Height(pRoot-&gt;right);
    <span class="hljs-keyword">int</span> delta = hl - hr;

    <span class="hljs-comment">// Lệch trái</span>
    <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">1</span>)
    {
        <span class="hljs-comment">// Lệch trái phải</span>
        <span class="hljs-keyword">if</span> (Height(pRoot-&gt;left-&gt;left) &lt; Height(pRoot-&gt;left-&gt;right))
        {
            LR(pRoot-&gt;left);
        }
        RR(pRoot);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">-1</span>)
    {
        <span class="hljs-comment">// Lệch phải trái</span>
        <span class="hljs-keyword">if</span> (Height(pRoot-&gt;right-&gt;right) &lt; Height(pRoot-&gt;right-&gt;left))
        {
            RR(pRoot-&gt;right);
        }
        LR(pRoot);
    }
}
</div></code></pre>
<h1 id="operation">Operation</h1>
<p>Thao tác thêm các node vào cây AVL tương tự như BST, nhưng có thể dẫn đến mất cân bằng. Vì vậy, sau khi thêm một node, ta cần kiểm tra cây AVL đã cân bằng hay chưa, nếu chưa thì cần cân bằng. Tương tự với thao tác xóa.</p>
<p>Để viết code cho thuật toán thêm và xóa node trong cây AVL, ta chỉ cần tận dụng hàm thêm và xóa cây BST rồi gọi hàm cân bằng sau khi thêm hoặc xóa.</p>
<h2 id="insert">Insert</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(NODE *&amp;pRoot, <span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>)
        pRoot = createNode(x);

    <span class="hljs-keyword">if</span> (x &lt; pRoot-&gt;key)
    {
        Insert(pRoot-&gt;left, x);
    }

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; pRoot-&gt;key)
    {
        Insert(pRoot-&gt;right, x);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Do sử dụng đệ quy nên khi giải phóng Stack, các node cha trên đường đi đến node vừa Insert cũng sẽ được kiểm tra cân bằng.</span>
    balanceTree(pRoot);
}
</div></code></pre>
<p>Với thao tác xóa thì cần lược bỏ trường hợp node rỗng không cần cân bằng.</p>
<h2 id="remove">Remove</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(NODE *&amp;pRoot, <span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (x &lt; pRoot-&gt;key)
        Remove(pRoot-&gt;left, x);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; pRoot-&gt;key)
        Remove(pRoot-&gt;right, x);
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-comment">// Trường hợp có không hoặc một con xử lý đồng thời</span>
        <span class="hljs-keyword">if</span> (pRoot-&gt;left == <span class="hljs-literal">nullptr</span>)
        {
            pRoot = pRoot-&gt;right;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pRoot-&gt;right == <span class="hljs-literal">nullptr</span>)
        {
            pRoot = pRoot-&gt;left;
        }

        <span class="hljs-comment">// Trường hợp có hai con</span>
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// Tìm node cha của thế mạng</span>
            NODE *<span class="hljs-built_in">move</span> = pRoot;
            NODE *parent = searchRightMin(<span class="hljs-built_in">move</span>);

            <span class="hljs-comment">// Ghi đè giá trị</span>
            pRoot-&gt;key = <span class="hljs-built_in">move</span>-&gt;key;

            <span class="hljs-comment">// Xóa node con thế mạng</span>
            <span class="hljs-keyword">if</span> (parent-&gt;left == <span class="hljs-built_in">move</span>)
            {
                temp = parent-&gt;left;
                parent-&gt;left = <span class="hljs-literal">nullptr</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;right == <span class="hljs-built_in">move</span>)
            {
                temp = parent-&gt;right;
                parent-&gt;right = <span class="hljs-literal">nullptr</span>;
            }
            <span class="hljs-keyword">delete</span> temp;
        }
    }

    <span class="hljs-comment">// Do tính chất đệ quy nên các node cha trên đường đến node con vừa xóa cũng sẽ được kiểm tra cân bằng.</span>
    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)
        balance(root);
}
</div></code></pre>
<h2 id="complexity">Complexity</h2>
<p>Các thao tác thêm, xóa và tìm kiếm trong AVL có độ phức tạp là $O(log_2(n))$ và không rơi vào trường hợp xấu nhất do tính chất tự cân bằng của cây.</p>
<p>Độ phức tạp của quá trình cân bằng là $O(1)$, bởi vì chỉ thực hiện tối đa là hai lần xoay cây và sử dụng các phép gán con trỏ.</p>
<p>Có một sự đánh đổi là khi ta cần tìm kiếm nhiều lần, ta chấp nhận xây dựng cây AVL. Tức là tùy mục đích sử dụng mà ta chấp nhận chi phí để Insert và cân bằng để xây dựng cây.</p>
<p>Thao tác duyệt cây thì vẫn cần độ phức tạp là $O(n)$.</p>
<h2 id="example-1">Example 1</h2>
<p>Giả sử ta cần thêm các node dưới đây vào cây AVL.</p>
<img src="img/Tree34.png">
<p>Ta sẽ thêm <strong>node 9</strong> là node gốc, sau đó thêm <strong>node 1</strong> là con trái của <strong>node 9</strong>, <strong>node 4</strong> là con phải của <strong>node 1</strong>. Cây trở nên mất cân bằng tại <strong>node 9</strong> theo trường hợp trái phải.</p>
<img src="img/Tree30.png">
<p>Ta cân bằng cây bằng cách xoay trái tại <strong>node 1</strong> và xoay phải ở <strong>node 9</strong>.</p>
<p>Sau đó, ta thêm vào cây <strong>node 2</strong> là con phải của <strong>node 1</strong>, <strong>node 3</strong> là con phải của <strong>node 2</strong>.</p>
<p>Lúc này cây mất cân bằng ở <strong>node 4</strong> theo kiểu trái phải, hoặc cây mất cân bằng ở <strong>node 1</strong> theo kiểu phải phải. Ta chọn xử lý trường hợp mất cân bằng kiểu phải phải.</p>
<p>Bởi vì khi xét từ khía cạnh thêm node vào cây AVL, <strong>node 1</strong> là node gần node lá nhất, gần nơi mà chúng ta cần thêm node. Do đó ta cần cân bằng ở đó trước. Ta xoay trái ở <strong>node 1</strong> để cân bằng cây.</p>
<img src="img/Tree31.png">
<p>Tiếp theo ta thêm vào cây <strong>node 5</strong> và <strong>node 8</strong>, bỏ qua <strong>node 9</strong> vì bị trùng. Cây trở nên mất cân bằng tại <strong>node 9</strong> theo kiểu trái phải. Xử lý bằng cách xoay trái ở <strong>node 5</strong> và xoay phải ở <strong>node 9</strong>.</p>
<img src="img/Tree32.png">
<p>Tiếp tục thêm <strong>node 6</strong>, <strong>node 7</strong> và bỏ qua <strong>node 4</strong>, cây mất cân bằng tại <strong>node 5</strong>. Tái cân bằng bằng cách xoay trái ở <strong>node 5</strong> vì đây là trường hợp phải phải.</p>
<img src="img/Tree33.png">
<h2 id="example-2">Example 2</h2>
<p>Dưới đây là một ví dụ không tốt cho cây AVL. Bởi vì trong thực tế các cây AVL không thể có độ lệch hai cây con của một node là 3 (<strong>node 8</strong>). Vì khi độ lệch là 2 thì cây AVL đã tự cân bằng.</p>
<img src="img/Tree35.png">
<h1 id="is-avl">Is AVL?</h1>
<p>Để kiểm tra một cây có phải là cây AVL hay không thì chúng ta tiến hành kiểm tra sự chênh lệch chiều cao giữa hai cây con của từng node.</p>
<p><strong>Code:</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAVL</span><span class="hljs-params">(NODE *pRoot)</span>
</span>{
    <span class="hljs-keyword">if</span> (pRoot != <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-comment">// Tính chiều cao của hai cây con</span>
        <span class="hljs-keyword">int</span> hl = Height(pRoot-&gt;left);
        <span class="hljs-keyword">int</span> hr = Height(pRoot-&gt;right);
        <span class="hljs-keyword">int</span> delta = hl - hr;

        <span class="hljs-comment">// Vi phạm AVL</span>
        <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">1</span> || delta &lt; <span class="hljs-number">-1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        
        <span class="hljs-comment">// Duyệt đến hai cây con</span>
        <span class="hljs-keyword">return</span> isAVL(pRoot-&gt;left) &amp;&amp; isAVL(pRoot-&gt;right);
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>