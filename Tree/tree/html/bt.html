<!DOCTYPE html>
<html>

<head>
  <title>bt.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="../../../main.css">
<div class="bg">
      <center><h1 class="bigtitle">Binary Tree</h1></center>
</div>
<h1 id="definition">Definition</h1>
<blockquote>
<p>Là cây mà mỗi đỉnh có tối đa 2 con (bậc tối đa là 2) và các giá trị của đỉnh không được trùng nhau.</p>
</blockquote>
<img src="../img/Tree2.png">
<h1 id="application">Application</h1>
<ul>
<li>Lưu trữ và tìm kiếm thông tin hiệu quả và dễ dàng.</li>
<li>Xây dựng cấu trúc Heap.</li>
<li>Cây tổ chức thi đấu.</li>
<li>Cây biểu thức số học, cây cú pháp</li>
<li>Sử dụng trong các thuật toán định tuyến.</li>
</ul>
<h1 id="general-properties">General Properties</h1>
<p>Ta gọi số đỉnh là <code>N</code>, chiều cao là <code>H</code>, <code>L</code> là số đỉnh lá và <code>i</code> là mức. Thuật ngữ &quot;node&quot; đôi khi dùng thay thế cho &quot;đỉnh&quot;. Có các loại cây nhị phân phổ biến sau:</p>
<p><strong>Số đỉnh ở mức i</strong> tối đa là $2^i$, tối thiểu là 1.</p>
<p>$$
\begin{align*}
1 \leq N_i &amp;\leq 2^i\
\end{align*}
$$</p>
<p>Một cây nhị phân với <strong>L lá</strong> có <strong>ít nhất $log_2(L) + 1$ mức</strong>.</p>
<p>$$
i \geq log_2(L) + 1
$$</p>
<p><strong>Số đỉnh tối đa của cây</strong> là $2^H –\ 1$ (nhiều nhất khi là cây nhị phân hoàn hảo)</p>
<p>$$
N \leq 2^H -\ 1
$$</p>
<p><strong>Số đỉnh tối thiểu của cây</strong> là $H$ trong trường hợp cây đó là một cây thẳng (suy thoái trở thành DSLK). Với một cây có $N$ đỉnh thì:</p>
<p>$$
N \geq H
$$</p>
<p><strong>Chiều cao của cây tối đa</strong> trong trường hợp cây thẳng (suy thoái trở thành DSLK). Vối một cây có $N$ đỉnh thì:</p>
<p>$$
H \leq N
$$</p>
<p><strong>Chiều cao của cây tối thiểu</strong> là $log_2(N\ +\ 1)$ với $N$ là số đỉnh trong cây.</p>
<p>$$
H \geq log_2(N\ +\ 1)
$$</p>
<p>Trong cây nhị phân đầy đủ, số đỉnh có 0 con luôn lớn hơn một đỉnh so với số đỉnh có 2 con. Ta gọi số đỉnh có 2 con là <code>T</code>. Ta có:</p>
<p>$$
L = T + 1
$$</p>
<p>Tính chất này có thể chứng minh bằng bổ đề bắt tay (Handshaking Lemma), là một bổ đề nói rằng tổng số bậc của đồ thị bằng hai lần số cạnh.</p>
<p>(Tham khảo <a href="https://www.geeksforgeeks.org/binary-tree-set-2-properties/?ref=lbp">geeksforgeeks</a>)</p>
<h1 id="types-of-binary-tree">Types of Binary Tree</h1>
<h2 id="pathological-or-degenerate-tree">Pathological or Degenerate Tree</h2>
<blockquote>
<p>Cây nhị phân suy thoái, là một cây chỉ có một con trái hoặc con phải.</p>
</blockquote>
<img src="../img/Tree25.png">
<h2 id="skewed-binary-tree">Skewed Binary Tree</h2>
<blockquote>
<p>Cây nhị phân lệch hay thẳng, là cây nhị phân suy thoái mà các đỉnh con của nó toàn bộ là con trái hoặc con phải.</p>
</blockquote>
<img src="../img/Tree26.png">
<h2 id="full-binary-tree">Full Binary Tree</h2>
<blockquote>
<p>Cây nhị phân đầy đủ. Là một cây nhị phân mà các đỉnh trong luôn có bậc là 2.</p>
</blockquote>
<p>Tức là nếu đỉnh đó có đỉnh con, thì phải có đầy đủ 2 đỉnh con. Nói cách khác, số bậc của các đỉnh sẽ là 0 hoặc là 2.</p>
<img src="../img/Tree10.png">
<h3 id="properties">Properties</h3>
<p>Gọi <code>I</code> là tổng số đỉnh trong. Số đỉnh:</p>
<ul>
<li>$L = I + 1$</li>
<li>$L = (n + 1) / 2$</li>
<li>$I = L - 1$</li>
<li>$I = (n - 1) / 2$</li>
<li>$N = 2I + 1$</li>
<li>$N = 2L - 1$</li>
</ul>
<h3 id="check-full-binary-tree">Check Full Binary Tree</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">(NODE *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-comment">// Nếu hai con khác nhau thì có root có thể có 1 hoặc 2 con</span>
        <span class="hljs-keyword">if</span> (root-&gt;left != root-&gt;right)
        {
            <span class="hljs-comment">// Nếu một trong hai bằng null thì là 1 con</span>
            <span class="hljs-comment">// Không thể có trường hợp cả hai đều null do đã xét ở trên</span>
            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> <span class="hljs-keyword">or</span> root-&gt;right == <span class="hljs-literal">nullptr</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> isFull(root-&gt;left) &amp;&amp; isFull(root-&gt;right);
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>Độ phức tạp thời gian $O(n)$, không gian $O(n)$ (lưu giữ các lời gọi đệ quy).</p>
<h2 id="perfect-binary-tree">Perfect Binary Tree</h2>
<blockquote>
<p>Cây nhị phân hoàn hảo: là một cây nhị phân mà các đỉnh lá của nó cùng nằm trên một mức. Hay nói cách khác, số bậc của đỉnh luôn là 2.</p>
</blockquote>
<img src="../img/Tree11.png">
<h3 id="properties">Properties</h3>
<p><strong>Tổng số đỉnh</strong> của cây nhị phân hoàn hảo là:</p>
<p>$$
N = 2^H –\ 1
$$</p>
<p>Khi biết được tổng số đỉnh, ta lấy $log_2$ sẽ có được <strong>chiều cao</strong> của cây:</p>
<p>$$
H = log_2(N + 1)
$$</p>
<p><strong>Tổng số đỉnh lá</strong> của cây nhị phân hoàn hảo chiều cao H là</p>
<p>$$
L = 2^{H - 1}
$$</p>
<p><strong>Độ sâu trung bình</strong> của một đỉnh trong cây nhị phân hoàn hảo là $O(log_2(n))$.</p>
<h3 id="check-perfect-binary-tree">Check Perfect Binary Tree</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPerfect</span><span class="hljs-params">(NODE *root)</span>
</span>{
    <span class="hljs-comment">// Đếm số node trong cây O(n)</span>
    <span class="hljs-keyword">int</span> nodes = countNode(root);

    <span class="hljs-comment">// Tính chiều cao của cây O(n)</span>
    <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">height</span>(root);

    <span class="hljs-comment">// Dùng biểu thức liên hệ giữa chiều cao và số node</span>
    <span class="hljs-keyword">return</span> (nodes == power(<span class="hljs-number">2</span>,h) - <span class="hljs-number">1</span>);
}
</div></code></pre>
<p>Độ phức tạp thời gian $O(n)$, không gian $O(n)$ (lưu giữ các lời gọi đệ quy).</p>
<h2 id="complete-binary-tree">Complete Binary Tree</h2>
<blockquote>
<p>Cây nhị phân hoàn chỉnh: là cây nhị phân mà mọi mức đều được lấp đầy, trừ mức cuối. Tất cả các đỉnh lá của mức cuối dồn hết qua bên trái hết mức có thể.</p>
</blockquote>
<img src="../img/Tree12.png">
<p><strong>So sánh giữa FBT và CBT</strong>:</p>
<img src="../img/Tree28.png">
<p>Do bị dồn sang phải nên không phải CBT.</p>
<img src="../img/Tree29.png">
<p>Do node 2 chỉ có một con nên không phải FBT.</p>
<img src="../img/Tree30.png">
<p>Thỏa mãn điều kiện mỗi node có 0 hoặc 2 con đồng thời các node được dồn sang trái hết mức có thể.</p>
<blockquote>
<p>Perfect Binary Tree là một Full Binary Tree và cũng là một Complete Binary Tree.</p>
</blockquote>
<h3 id="check-complete-binary-tree">Check Complete Binary Tree</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">(NODE *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-built_in">queue</span>&lt;NODE *&gt; q;
    q.push(root);
    <span class="hljs-keyword">bool</span> <span class="hljs-built_in">end</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)
    {
        NODE *curr = q.front();
        q.pop();

        <span class="hljs-keyword">if</span> (curr-&gt;left != <span class="hljs-literal">nullptr</span>)
            q.push(curr-&gt;left);

        <span class="hljs-comment">// Nếu có con trái bị null thì đánh dấu</span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">end</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (curr-&gt;right != <span class="hljs-literal">nullptr</span>)
        {
            <span class="hljs-comment">// Con phải khác null mà con trái null</span>
            <span class="hljs-comment">// Thì không phải là CBT</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">end</span> == <span class="hljs-literal">true</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            q.push(curr-&gt;right);
        }
    }

    <span class="hljs-comment">// Pass hết sau khi duyệt thì là CBT</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<h3 id="the-story-behind">The story behind</h3>
<p>Nếu một node có con trái là null, thì con phải của nó bắt buộc phải null. Hoặc con trái không null thì con phải có thể null hoặc không.</p>
<p>Nói cách khác, node null phải là node cuối cùng trong cây khi duyệt theo mức. Nếu tồn tại node khác null sau khi có node null, thì là vi phạm CBT.</p>
<p>Áp dụng tính chất này chúng ta sử dụng duyệt theo mức để xét hai node con của một node bất kỳ để kiểm tra CBT.</p>
<p>(Tham khảo <a href="https://www.youtube.com/watch?v=j16cwbLEf9w&amp;t=191s">Nick White</a> )</p>
<h3 id="complexity">Complexity</h3>
<p>Độ phức tạp thời gian $O(n)$.
Độ phức tạp không gian $O(n)$.</p>
<ul>
<li>Bởi vì kích thước Queue phụ thuộc vào số node lá của cây . Mà số node lá của cây tối đa là
$$
L  \leq 2^{H - 1}
$$</li>
<li>Cây CBT có chiều cao tiệm cận chiều cao nhỏ nhất, nên
$$
H = log_2(N + 1)
$$</li>
<li>Suy ra số node lá của cây tối đa là
$$
L \leq (N + 1)/2
$$</li>
<li>Thay vào ta có độ phức tạp không gian cho Queue là
$$
O((N + 1)/2) \sim O(n)
$$</li>
<li>Ngoài ra còn có độ phức phức tạp không gian cho các lời gọi đệ quy: $O(n)$. Tính tổng vẫn được kết quả $O(n)$.</li>
</ul>
<h3 id="heap">Heap</h3>
<p>Cấu trúc Heap chính là một ứng dụng của cây nhị phân hoàn chỉnh (CBT). Có hai dạng: Max Heap và Min Heap.</p>
<p><strong>Max Heap</strong> là cây nhị phân hoàn chỉnh mà ở đó mỗi đỉnh đều lớn hơn các đỉnh con của nó.</p>
<p><strong>Min Heap</strong> là ngược lại, mỗi đỉnh luôn bé hơn các đỉnh con của nó.</p>
<blockquote>
<p>Trong tất cả các cây nhị phân có N đỉnh, thì CBT là cây có chiều cao thấp nhất và SBT (Skewed Binray Tree) là cây có chiều cao cao nhất.</p>
</blockquote>
<h2 id="balanced-binary-tree">Balanced Binary Tree</h2>
<p>Cây nhị phân cân bằng là cây nhị phân mà mỗi đỉnh có sự khác biệt giữa chiều cao cây con trái và cây con phải không quá 1. Đồng thời cây con trái và cây con phải đều phải là cây nhị phân cân bằng.</p>
<h3 id="check-balanced-binary-tree">Check Balanced Binary Tree</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(NODE *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-comment">// Tính chiều cao của hai cây con</span>
        <span class="hljs-keyword">int</span> leftHeight = <span class="hljs-built_in">height</span>(root-&gt;left);
        <span class="hljs-keyword">int</span> rightHeight = <span class="hljs-built_in">height</span>(root-&gt;right);
        <span class="hljs-keyword">int</span> delta = leftHeight - rightHeight;

        <span class="hljs-comment">// Nếu chênh lệch quá 1 thì không cân bằng</span>
        <span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> delta &lt; <span class="hljs-number">-1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-comment">// Tiếp tục xét cho các cây con</span>
        <span class="hljs-keyword">return</span> isBalanced(root-&gt;left) <span class="hljs-keyword">and</span> isBalanced(root-&gt;right);
    }
    <span class="hljs-comment">// Nếu pass hết sau khi duyệt thì là cân bằng</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<img src="../img/Tree27.png">
<p>(Hình ảnh tham khảo từ <a href="https://www.programiz.com/dsa/binary-tree">programmingquiz</a>)</p>
<h1 id="enumerate-the-binary-tree">Enumerate the Binary Tree</h1>
<p>(Liệt kê các cấu hình có thể có của cây)</p>
<p>Nếu ta xét một cây nhị phân T, gọi $T(n)$ là số đỉnh trong cây nhị phân đó. Bài toán tìm số cây nhị phân có thể có tạo thành từ N đỉnh tồn tại các trường hợp cơ bản sau:</p>
<img src="../img/Tree3.png">
<p>Tức là
$T(0) = 1$ (chỉ có duy nhất một cây rỗng)
$T(1) = 1$
$T(2) = 2$</p>
<p>Để tính $T(3)$, ta thực hiện một bài toán đếm đơn giản. Ta xét số đỉnh con ở cây trái, do $N = 3$, nên số đỉnh con tối đa là 2. Có hai trường hợp: có 2 con hoặc có 1 con.</p>
<p>Với trường hợp số đỉnh con bên trái là 1 và con bên phải là 0, có hai cách chọn con tiếp theo cho nhánh này, hoặc là con trái hoặc là con phải. Tương tự cây con bên phải cũng có hai trường hợp.</p>
<img src="../img/Tree4.png">
<img src="../img/Tree5.png">
<p>Trường hợp số đỉnh con bên trái và bên phải là 1, tức là cây không có mức 3. Thì vẫn có thể tạo nên một cây.</p>
<p>Vậy có 5 cách để tạo cây từ N đỉnh với N = 3.</p>
<p>Viết lại dưới dạng công thức:</p>
<img src="../img/Tree6.png">
<p>Tương tự cho $T(4)$:</p>
<img src="../img/Tree7.png">
<p>Đây là một dãy số đặc biệt có tên là dãy Catalan. Công thức để tính số Catalan thứ n là:</p>
<img src="../img/Tree8.png">
<p>Dãy số này có thể dùng đệ quy để tính toán.</p>
<p>Vậy ta rút ra từ công thức ở trên cách tính $T(n)$ tổng quát là:</p>
<img src="../img/Tree9.png">
<p>Cũng là số cấu hình cây nhị phân có thể có tạo thành từ N đỉnh cho trước.</p>
<p>(Tham khảo <a href="https://www.geeksforgeeks.org/enumeration-of-binary-trees/">geeksforgeeks</a>)</p>
<h1 id="traversal">Traversal</h1>
<h2 id="idea">Idea</h2>
<p>Duyệt cây là đi qua tất cả các node, mỗi node một lần.</p>
<p>Có ba phép duyệt cây là:</p>
<ul>
<li>Pre-order (Duyệt trước)</li>
<li>Post-order (Duyệt sau)</li>
<li>In-order (Duyệt giữa)</li>
</ul>
<p><strong>Duyệt trước</strong> là duyệt node gốc trước, sau đó tới các node con từ trái sang phải.</p>
<p><strong>Duyệt sau</strong> là duyệt các node con từ trái sang phải, rồi mới tới node gốc.</p>
<p><strong>Duyệt giữa</strong> là duyệt node gốc sau khi duyệt node đầu và trước khi duyệt node cuối.</p>
<p>Tức là sau khi duyệt con đầu tiên, ta mới duyệt đến node gốc, rồi duyệt tiếp các con còn lại.
Nếu không tồn tại node con đầu tiên, thì node gốc sẽ ở vị trí đầu tiên trong danh sách kết quả, mặc dù thứ tự duyệt của nó là thứ 2.</p>
<p>Chẳng hạn ta có cây như hình dưới.</p>
<img src="../img/Tree13.png">
<p><strong>Duyệt trước</strong> : $2-7-2-6-5-11-5-9-4$</p>
<p><strong>Duyệt giữa</strong> : $2-7-5-6-11-2-5-4-9$</p>
<p><strong>Duyệt sau</strong> : $2-5-11-6-7-2-5-4-9$</p>
<blockquote>
<p>Kết quả duyệt giữa của Search Tree (không chỉ có BST – Binary Search Tree) sẽ có dạng dãy số được sắp xếp tăng dần.</p>
</blockquote>
<p><strong>Duyệt theo mức</strong> (Level Order Traveral). Chúng ta duyệt cây bằng cách duyệt theo thứ tự từ trên xuống, từ trái qua. Ở cây trên, kết quả sau khi duyệt là: $2–7–5–2–6–9–5–11–4$</p>
<h2 id="code">Code</h2>
<p><strong>Duyệt trước</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(node *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">//!Xử lý root tùy theo nhu cầu</span>
    preOrder(root-&gt;pLeft);
    preOrder(root-&gt;pRight);
}
</div></code></pre>
<p><strong>Duyệt sau</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(node *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">return</span>;
    }

    postOrder(root-&gt;pLeft);
    postOrder(root-&gt;pRight);
    <span class="hljs-comment">//Xử lý root tùy theo nhu cầu</span>
}
</div></code></pre>
<p><strong>Duyệt giữa</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(node *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
    {
        <span class="hljs-keyword">return</span>;
    }

    inOrder(root-&gt;pLeft);
    <span class="hljs-comment">//!Xử lý root tùy theo nhu cầu</span>
    inOrder(root-&gt;pRight);
}
</div></code></pre>
<h1 id="counting">Counting</h1>
<p><strong>Đếm tổng số node trong cây</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNode</span><span class="hljs-params">(NODE *pRoot)</span>
</span>{
    <span class="hljs-comment">// Trường hợp cơ bản</span>
    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Đếm node hiện tại và số node của các cây con</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNode(pRoot-&gt;left) + countNode(pRoot-&gt;right);
}
</div></code></pre>
<p><strong>Đếm số node lá trong cây</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countLeaf</span><span class="hljs-params">(NODE *pRoot)</span>
</span>{
    <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">//Chỉ bằng nhau khi cả hai đều là null</span>
    <span class="hljs-keyword">if</span> (pRoot-&gt;left == pRoot-&gt;right)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> countLeaf(pRoot-&gt;left) + countLeaf(pRoot-&gt;right);
}
</div></code></pre>
<p><strong>Đo chiều cao của cây</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(NODE *root)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">int</span> leftHeight = <span class="hljs-built_in">height</span>(root-&gt;left);
    <span class="hljs-keyword">int</span> rightHeight = <span class="hljs-built_in">height</span>(root-&gt;right);
    <span class="hljs-keyword">if</span> (leftHeight &gt; rightHeight)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftHeight;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightHeight;
}
</div></code></pre>
<p><strong>Đo chiều cao của node</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">heightNode</span><span class="hljs-params">(NODE *root, <span class="hljs-keyword">int</span> value)</span>
</span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (value &lt; root-&gt;key)
        <span class="hljs-keyword">return</span> heightNode(root-&gt;left, value);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; root-&gt;key)
        <span class="hljs-keyword">return</span> heightNode(root-&gt;right, value);

    <span class="hljs-comment">// Xem node đó như một cây nhị phân và tính chiều cao của cây</span>
    <span class="hljs-comment">// Bởi vì chiều cao của node gốc chính là chiều cao của cây.</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root);
}
</div></code></pre>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>