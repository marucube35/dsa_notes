<!DOCTYPE html>
<html>

<head>
  <title>Merge.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>
<link rel="stylesheet" href="file:///g%3A/MATERIAL/Computer/CTDL%20%26%20GT/Note/Sort/md/main.css" type="text/css">
<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="main.css">
<h1 id="merge-sort">Merge Sort</h1>
<h2 id="%C3%BD-t%C6%B0%E1%BB%9Fng">Ý tưởng</h2>
<p>Thuật toán Merge Sort là một thuật toán ứng dụng phương pháp chia để trị, thuật toán này gồm hai phần.</p>
<p>Phần đầu tiên, chia các mảng thành hai không gian con, nếu các không gian con này có nhiều hơn một phần tử thì tiếp tục chia đôi. Ngược lại có duy nhất một phần tử hoặc không có phần tử nào (trong trường hợp dãy lẻ) thì bắt đầu trộn lại (gọi đệ qui).</p>
<p>Phần thứ hai chính là quá trình trộn, trong quá trình trộn sẽ kết hợp sắp xếp mảng.
Trộn 2 mảng con được thực hiện như sau:</p>
<ol>
<li>Chọn phần tử min ở vị trí đầu của một trong hai mảng, xếp vào mảng cần trộn.</li>
<li>Phần tử nào đã xếp vào thì xóa đi, vị trí đầu của mảng là phần tử tiếp theo.</li>
<li>Nếu chưa đến cuối mảng thì lặp lại bước 1. Nếu đã đến cuối của một mảng (luôn xảy ra một mảng đã sắp hết và một mảng thì chưa), thì thêm toàn bộ mảng kia vào mảng cần sắp.</li>
</ol>
<img src = "../img/Sort17.png">
<h2 id="%C4%91%E1%BA%A7u-v%C3%A0o-%E2%80%93-%C4%91%E1%BA%A7u-ra">Đầu vào – Đầu ra</h2>
<ul>
<li>Input: Mảng A gồm n phần tử chưa sắp xếp, vị trí bên trái và vị trí bên phải của mảng hoặc phân hoạch.</li>
<li>Output: Mảng A đã sắp xếp.</li>
</ul>
<h2 id="ph%C3%A2n-t%C3%ADch-thu%E1%BA%ADt-to%C3%A1n">Phân tích thuật toán</h2>
<p>Không tối ưu bộ nhớ vì dùng mảng tạm trong quá trình trộn. Nhanh hơn Quick Sort vì thời gian thực hiện Merge Sort có bậc là $O(nlog_2(n))$, còn trong trường hợp tốt nhất hoặc trung bình Quick Sort mới có độ phức tạp là $O(nlog_2(n))$. Thường dùng Merge Sort để sắp lượng dữ liệu lớn ở bộ nhớ ngoài.</p>
<p>Do tính chất Non - inplace, thuật toán Merge Sort thường cần dùng bộ nhớ tạm trong quá trình thực thi, vì vậy mà thuật toán này thường được sử dụng trong các cấu trúc dữ liệu khác mảng chẳng hạn như Linked List hoặc File.</p>
<p><strong>Điểm mạnh</strong></p>
<ul>
<li>Stable Sort.</li>
<li>Có độ phức tạp ở ba case là như nhau nên mang tính ổn định.</li>
<li>Tốc độ nhanh đối với những dữ liệu có kích thước lớn.</li>
<li>Ứng dụng trong External Sorting.</li>
</ul>
<p><strong>Điểm yếu</strong></p>
<ul>
<li>Sử dụng bộ nhớ phụ, nếu dùng Linked List thì có thể giảm bớt vấn đề này (giảm ra sao ?).</li>
<li>Đối với lượng dữ liệu nhỏ thì không hiệu quả.</li>
<li>Không thể nhận biết mảng đã sắp xếp.</li>
</ul>
<blockquote>
<p>Khi nào thì sử dụng?</p>
</blockquote>
<ul>
<li>Khi cấu trúc dữ liệu không hỗ trợ truy cập ngẫu nhiên (dùng linked list).</li>
<li>Sắp xếp ở bộ nhớ ngoài, khi truy cập trực tiếp hao phí rất nhiều so với truy cập tuần tự ?.</li>
<li>Cần tính ổn định.</li>
</ul>
<h2 id="ph%C3%A2n-t%C3%ADch-%C4%91%E1%BB%99-ph%E1%BB%A9c-t%E1%BA%A1p-thu%E1%BA%ADt-to%C3%A1n">Phân tích độ phức tạp thuật toán</h2>
<p>Ta đã biết trong các bài toán chia đôi không gian thuật toán làm hai như Binary Search hoặc Quick Sort thì độ phức tạp của việc chia ra như vậy là $O(log_2(n))$. Nói cách khác, ta cần $k = O(log_2(n)$ bước để chia một mảng n phần tử thành các mảng có 1 phần tử. Ngược lại cũng cần $k = O(log_2(n))$ lần nhân đôi một phần tử để trở thành mảng có n phần tử.</p>
<p>Từ đó ta có được độ phức tạp của bước chia mảng trong Merge Sort là $O(log_2(n))$.</p>
<p>Ngoài ra, khi trộn mảng, ta phải duyệt qua từng phần tử của hai mảng con bất kỳ. Như vậy độ phức tạp phần trộn là $O(n + m)$, với n và m là kích thước của hai mảng con.</p>
<p>Nói cách khác, nếu gọi T(n) là độ phức tạp thời gian của thuật toán, ta có lần chia đầu tiên sẽ là</p>
<p>$$
T(n) = 2 * T(n/2) + n
$$</p>
<p>$2 * T(n/2)$ là độ phức tạp cho hai mảng con có kích thước bằng hoặc chênh nhau một phần tử.
n là số lần duyệt qua n phần tử trong mỗi lần trộn. Do có k lần chia cũng như k lần trộn nên ta gộp chúng lại với nhau.</p>
<p>Lần chia thứ hai</p>
<p>$$
T(n) = 2 * (2 * T(n/4) + n/2) + n\
= 4 * T(n/4) + 2 * n
$$</p>
<p>Lần chia thứ ba</p>
<p>$$
T(n) = 4 * (2 * T(n/8) + n/4) + 2 * n\
= 8 * T(n/8) + 3 * n
$$</p>
<p>Tổng quát cho lần chia thứ k</p>
<p>$$
T(n) = 2^k * T(n/2^k)  + k * n
$$</p>
<p>Ta có số lần chia là $k = log_2(n)$ (luôn chia đôi), thay vào biểu thức trên, có được:</p>
<p>$$
T(n) = n * T(1)  + n * log_2(n)\
= n * (log_2(n) + 1)
$$</p>
<p>Kết luận độ phức tạp thuật toán là $O(nlog_2(n))$.</p>
<p>Ba trường hợp của Merge Sort là như nhau bởi vì Merge Sort luôn chia đôi mảng và quét hết qua n phần tử trong các lần trộn ở mỗi mức.</p>
<p>Độ phức tạp không gian cũng thế, ở ba trường hợp đều là độ phức tạp tuyến tính.</p>
<h2 id="%C4%91%E1%BB%99-ph%E1%BB%A9c-t%E1%BA%A1p-thu%E1%BA%ADt-to%C3%A1n">Độ phức tạp thuật toán</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Cases</th>
<th style="text-align:left">Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Best case</td>
<td style="text-align:left">$O(nlog_2(n))$</td>
</tr>
<tr>
<td style="text-align:left">Worst case</td>
<td style="text-align:left">$O(nlog_2(n))$</td>
</tr>
<tr>
<td style="text-align:left">Average case</td>
<td style="text-align:left">$O(nlog_2(n))$</td>
</tr>
</tbody>
</table>
<p>Space Complexity: $O(n)$.</p>
<h2 id="gi%E1%BA%A3i-thu%E1%BA%ADt-m%E1%BA%ABu">Giải thuật mẫu</h2>
<h3 id="ph%E1%BA%A7n-chia-m%E1%BA%A3ng">Phần chia mảng</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span>
</span>{
    <span class="hljs-keyword">if</span>(left &lt;= right) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">//Tìm vị trí giữa mảng để chia</span>
    <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;
    mergeSort(a,left,mid);
    mergeSort(a,mid + <span class="hljs-number">1</span>,right);
    merge(a,left,mid,right);
}
</div></code></pre>
<h3 id="ph%E1%BA%A7n-tr%E1%BB%99n-m%E1%BA%A3ng">Phần trộn mảng</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, intleft, intmid, intright)</span>
</span>{
    <span class="hljs-keyword">int</span> *temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];
    <span class="hljs-comment">//Mảng thứ nhất từ left đến mid, mảng thứ hai từ mid + 1 đến right</span>
    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> i = left;
    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;

    <span class="hljs-comment">//?Khi hai mảng con chưa xét đến phần tử cuối</span>
    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;=right)
    {
        <span class="hljs-comment">//?So sánh phần tử đầu mỗi mảng và cho vào mảng phụ</span>
        <span class="hljs-keyword">if</span> (a[i] &lt;= a[j])
        {
            temp[k++] =a[i++];
        }
        <span class="hljs-keyword">else</span>
        {
            temp[k++] =a[j++];
        }
    }

    <span class="hljs-comment">//?Chép các phần tử còn lại (nếu còn)</span>
    <span class="hljs-keyword">while</span> (i &lt;= mid)
    {
        temp[k++] =a[i++];
    }
    <span class="hljs-keyword">while</span> (j &lt;= right)
    {
        temp[k++] =a[j++];
    }

    <span class="hljs-comment">//?Chép mảng phụ lại vào mảng chính</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++)
    {
        <span class="hljs-comment">//Index của a tính từ left</span>
        a[i] =temp[i - left];
    }
}
</div></code></pre>
<h2 id="bi%E1%BA%BFn-th%E1%BB%83">Biến thể</h2>
<h3 id="bottom---up">Bottom - Up</h3>
<p>Một phiên bản khác của Merge Sort không dùng đến việc chia mảng là Bottom - Up Merge Sort. Thuật toán này sẽ trộn các phần tử liền kề với nhau rồi mở rộng ra. Chẳng hạn như nó sẽ trộn 2 phần tử liên tiếp thành mảng con 2 phần tử. Sau đó nó sẽ trộn tiếp 2 mảng gồm 2 phần tử với nhau thành mảng 4 phần tử. Cứ như thế cho đến khi trộn hết mảng cũng là lúc mảng đã được sắp xếp.</p>
<img src = "../img/Sort18.png">
<img src = "../img/Sort19.png">
<img src = "../img/Sort20.png">
<p>(Hình ảnh tham khảo <a href="https://www.interviewbit.com/tutorial/merge-sort-algorithm/">interviewbit</a>)</p>
<h3 id="natural-merge-sort">Natural Merge Sort</h3>
<p>Tham khảo <a href="https://en.wikipedia.org/wiki/Merge_sort#Natural_merge_sort">wikipedia</a>.</p>
<p>Ngoài ra còn có Natural Merge Sort, thuật toán này sẽ không chia trực tiếp mà chẳng cần quan tâm đến thứ tự đã sắp xếp như Merge Sort. Ở đây nó sẽ xem xét các đường chạy (dãy đã có thứ tự). Trong khi Merge Sort cứng nhắc về số lần phân hoạch dựa vào chiều dài dãy là k, thì Natural Merge Sort sẽ dựa vào số đường chạy và mảng được sắp xếp là mảng chỉ có một đường chạy. Thực tế, người ta sử dụng Natural nhiều hơn trong trường hợp dãy đã sắp xếp một phần nào đó.</p>
<p>Bởi vì Merge Sort thông thường không nhận biết được một dãy đã sắp xếp nên trong thực tế người ta không dùng Merge Sort thuần để ứng dụng. Thay vào đó họ sử dụng Natural Merge Sort tận dụng các đường chạy để tối ưu thuật toán.
Đường chạy là một dãy tăng không giảm. Ví dụ dãy 7 8 1 2 5 6 4 3 sẽ có bốn đường chạy là (7, 8), (1, 2, 5, 6), (4) và (3). Khi chọn ra được các đường chạy trong cùng một mảng, chúng ta sẽ tiến hành trộn tuần tự các đường chạy đó lại với nhau. Ví dụ sắp xếp cho dãy trên, ta có:</p>
<img src = "../img/Sort21.png">
<p>Trộn hai đường chạy đầu tiên lại với nhau</p>
<img src = "../img/Sort22.png">
<p>Tiếp tục trộn</p>
<img src = "../img/Sort23.png">
<p>Cuối cùng ta được dãy đã sắp xếp
<img src = "../img/Sort24.png"></p>
<p>Thay vì phân ra quá nhiều mảng con, phiên bản này của Merge Sort chỉ phân ra k đường chạy nhất định rồi trộn chúng lại với nhau.</p>
<p>Một scenario điển hình là sắp xếp dữ liệu có kích thước lớn, người ta sẽ đưa nó vào bộ nhớ trong sắp xếp một phần rồi đem ra bộ nhớ ngoài để sử dụng Natural Merge Sort.</p>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>