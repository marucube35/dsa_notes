<!DOCTYPE html>
<html>

<head>
  <title>Flash.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="../../main.css">
<div class="bg">
     <center><h1 class="bigtitle">Flash Sort</h1></center>
</div>
<p>Flash Sort là một thuật toán sắp xếp dựa trên sự phân bố của dữ liệu, cụ thể là phân bố đều, được Karl-Dietrich Neubert phát minh năm 1998. Nếu chúng ta không xác định được phân bố của một tập dữ liệu, khi dữ liệu có khả năng phân bố không đều, thì độ phức tạp có thể trở thành O(n2).</p>
<h1 id="idea">Idea</h1>
<p>Thuật toán Flash Sort gồm ba công việc: phân lớp, hoán vị và sắp xếp cục bộ.</p>
<ul>
<li>Phân lớp giúp xác định kích thước của từng lớp phần tử.</li>
<li>Hoán vị giúp hoán vị các phần tử giữa các lớp này.</li>
<li>Sắp xếp cục bộ để sắp xếp các phần tử trong cùng một lớp.</li>
</ul>
<p>Idea chung của Flash Sort là chia để trị, tương tự như Merge Sort hay Quick Sort. Thay vì chia thành hai mảng con đến khi nào không chia được nữa thì Flash Sort chia thành m phân lớp.</p>
<h2 id="classification">Classification</h2>
<p>Giả sử các phần tử trong danh sách là <code>a[i]</code> và được phân bố đều rải rác. Chúng ta cần tìm vị trí của phần tử <code>a[i]</code> trong một lớp dữ liệu. Việc tính toán này có thể tính dựa trên giá trị của phần tử đó mà không cần thực hiện các phép so sánh.</p>
<p>Đầu tiên, ta đi tìm hệ số <code>m</code> đại diện cho số phân lớp. Sử dụng công thức sau với <code>n</code> là số phần tử và <code>c</code> là một hằng số tùy chỉnh.</p>
<p>$$
m = C * n
$$</p>
<ul>
<li>Độ phức tạp thời gian và không gian: $O(1)$.</li>
</ul>
<p>Tiếp theo tìm giá trị nhỏ nhất <code>min</code> và lớn nhất <code>max</code>.</p>
<ul>
<li>Độ phức tạp thời gian $O(n)$ và không gian $O(1)$.</li>
</ul>
<p>Sau đó ta đi tìm phân lớp của phần tử <code>a[i]</code> bất kỳ. Có biểu đồ sau:</p>
<img src = "../img/sort35.png">
<p>Ta lấy đoạn màu đỏ chia cho đoạn màu xanh dương được</p>
<p>$$
\cfrac{a[i] - min}{max - min}
$$</p>
<p>Sau đó nhân biểu thức trên cho <code>m - 1</code> với <code>m</code> là số lượng phân lớp, lý do trừ đi 1 là vì các phân lớp bắt đầu từ 0. Suy ra được công thức tính phân lớp <code>k</code> cho phần tử <code>a[i]</code> bất kỳ:</p>
<p>$$
k(a[i]) = int \bigg[\cfrac{(m - 1)(a[i] - min)}{max - min}\bigg]
$$</p>
<p>Kết quả sẽ có giá trị từ 0 đến m. Trung bình sẽ có <code>n/m</code> phần tử ở mỗi lớp.</p>
<ul>
<li>Do cần phải tìm phân lớp cho tất cả các phần tử nên độ phức tạp thời gian là $O(n)$, độ phức tạp không gian là $O(1)$.</li>
</ul>
<p>Ta cũng tiến hành đếm số lượng phần tử mỗi phân lớp trong lúc tìm phân lớp của phần tử <code>a[i]</code>.
Khi đã có được số lượng phần tử này rồi thì ta cần tính vị trí cuối cùng của từng phân lớp (tính tích lũy tương tự Counting Sort). Vị trí cuối cùng này sẽ được lưu trong mảng phụ <code>L[m]</code>. Việc tính tích lũy này sẽ phục vụ cho việc chèn phần tử <code>a[i]</code> nằm sai phân lớp về đúng vị trí phân lớp của nó do <code>L[m]</code> quy định.</p>
<ul>
<li>Độ phức tạp thời gian $O(m)$, độ phức tạp không gian $O(m)$.</li>
</ul>
<h2 id="permutation">Permutation</h2>
<p>Bước này là bước quan trọng của thuật toán, nó sẽ kiểm tra giá trị <code>k</code> của phần tử <code>a[i]</code> bất kỳ. Nếu đúng chỗ thì xét tiếp phần tử tiếp theo, sai chỗ thì sẽ hoán vị với phần tử đang nằm ở phân lớp <code>k</code> mà nó đáng lẽ phải ở đó.</p>
<img src = "../img/sort36.png">
<p>Giả sử trong hình minh họa trên, giá trị phân lớp <code>k</code> của  <code>a[i]</code> là 2 (Bước 1). Ta tìm vị trí mà phân lớp 2 cho phép hoán vị là <code>L[2]</code> (Bước 2). <code>L[2]</code> đang trỏ đến <code>a[j]</code>. Ta sẽ hoán vị <code>a[i]</code> và  <code>a[j]</code> (Bước 3).</p>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>