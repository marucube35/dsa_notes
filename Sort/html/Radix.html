<!DOCTYPE html>
<html>

<head>
  <title>Radix.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>
<link rel="stylesheet" href="file:///g%3A/MATERIAL/Computer/DSA/Note/Sort/md/main.css" type="text/css">
<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="main.css">
<div class="bg">
     <center><h1 class="bigtitle">Radix Sort</h1></center>
</div>
<p><strong>Radix – cơ số</strong>: Thuật toán này sắp xếp dựa trên cơ số (2, 8, 10, 16), mỗi cơ số có một cách biểu diễn riêng cho các giá trị phụ thuộc vào số lượng ký số (số ký tự để biểu diễn giá trị). Do đó nếu giá trị không thể hiện dưới dạng một số cơ số nhất định nào đó (chẳng hạn số thực hoặc số âm) thì việc sắp xếp sẽ khá khó khăn.</p>
<h1 id="idea">Idea</h1>
<p>Radix sort gồm hai bước là phân loại và sắp xếp. Đầu tiên phân loại các phần tử về đúng phân lớp, sau đó tiến hành sắp xếp các phần tử trong cùng một phân lớp. Hai bước này được thực hiện song song nhau. Radix Sort có thể sử dụng Counting Sort (là một Stable Sort) làm hàm con của nó.</p>
<p>Ví dụ cho mảng dưới đây</p>
<p>$$
121, 432, 564, 23, 1, 45, 788
$$</p>
<img src = "../img/Sort34.png">
<p>Ở vòng lặp 1 thực hiện phân các giá trị vào 6 lớp (1, 2, 3, 4, 5, 8) dựa trên các giá trị của hàng đơn vị (luôn có 9 lớp đối với cơ số 10). Vòng lặp hai thì cũng phân vào 6 lớp (0, 2, 3, 4, 6, 8). Cuối cùng phân vào 5 lớp (0, 1, 4, 5, 7). Và chính việc cho vào các phân lớp như vậy cũng làm cho dữ liệu được sắp xếp.</p>
<p><strong>Các bước thực hiện</strong>:</p>
<ol>
<li>Tìm phần tử lớn nhất <code>max</code>. Ở đây <code>max = 788</code> và nó có 3 ký tự tương ứng với 3 vòng lặp.</li>
<li>Gọi Counting Sort cho từng hàng số. (Ví dụ này có hàng đơn vị, hàng chục và hàng trăm).</li>
<li>Lặp lại bước hai đến khi nào xét hết mọi ký tự.</li>
</ol>
<p>Vòng lặp đầu tiên ta gọi Counting Sort cho hàng đơn vị.</p>
<img src = "../img/Sort31.png">
<p>Chúng ta có thể thấy thứ tự giữa các số có cùng hàng đơn vị vẫn không đổi (Stable).</p>
<p>Tiếp theo cho hàng chục</p>
<img src = "../img/Sort32.png">
<p>Cuối cùng là hàng trăm và kết thúc thuật toán</p>
<img src = "../img/Sort33.png">
<p>(Hình ảnh tham khảo từ <a href="https://www.programiz.com/dsa/radix-sort">programmingquiz</a>)</p>
<h1 id="properties">Properties</h1>
<p><strong>Điểm mạnh</strong></p>
<ul>
<li>Stable Sort.</li>
<li>Không phụ thuộc vào dãy đầu vào.</li>
<li>Tốc độ nhanh khi số lượng ký số nhỏ. Chẳng hạn có n phần tử nhưng phần tử có chiều dài ký số lớn nhất là 7, thì chỉ cần 7 lần sắp xếp.</li>
<li>Tiết kiệm bộ nhớ hơn Counting Sort nếu <code>b</code> là một cơ số đủ nhỏ.</li>
</ul>
<p><strong>Điểm yếu</strong></p>
<ul>
<li>Kém hiệu quả nếu số lượng ký số lớn hoặc cơ số lớn.</li>
<li>Kém linh hoạt hơn các loại Sort khác do phụ thuộc vào số lượng ký số và cơ số.</li>
</ul>
<p><strong>Ứng dụng</strong></p>
<ul>
<li>Sắp xếp thư từ dựa trên mã bưu chính (Postal Code hoặc ZIP Code)</li>
</ul>
<blockquote>
<p>Khi nào nên sử dụng?</p>
</blockquote>
<ul>
<li>Tập dữ liệu lớn có khoảng giá trị nhỏ lặp lại liên tục, chẳng hạn như một triệu phần tử có giá trị từ 0 đến 100.</li>
<li>Tập dữ liệu không lặp lại nhưng lại có cùng số ký số (Best case), chẳng hạn như sắp xếp một triệu tài khoản ngân hàng đều có 14 ký số.</li>
</ul>
<p>(Tham khảo <a href="https://www.quora.com/When-should-we-use-radix-sort-Counting-sort-and-bucket-sort-for-sorting-purpose">quora</a>).</p>
<h1 id="complexity-analysis">Complexity Analysis</h1>
<p>Bước tìm Max luôn được thực hiện, có chi phí $O(n)$.</p>
<p>Bước gọi Counting Sort thì được thực hiện <code>d</code> lần tương ứng với số chữ số của <code>max</code>. Số chữ số <code>d</code> là $O(log_b(max))$. Mỗi lần lặp tốn chi phí của Counting Sort là $O(n + k)$.</p>
<p>Với <code>k</code> ở đây là giá trị lớn nhất của các phần tử trong một lần gọi Counting Sort. Nhưng do ta sort theo từng hàng số nên giá trị <code>k</code> chỉ có trong khoảng <code>[0;9]</code> (nếu chọn hệ cơ số thập phân). Tổng quát hơn, giá trị <code>k</code> phụ thuộc vào hệ cơ số, nên ta thay nó thành <code>b</code> (base).</p>
<p>Kết luận tổng chi phí cho Radix Sort sẽ là $O(d*(n + b))$</p>
<p><strong>Worst case</strong>
Trường hợp xấu nhất xảy ra khi tất cả phần tử đều có cùng số chữ số nhưng có một phần tử có số chữ số cực kỳ lớn so với phần còn lại. Nếu số chữ số của số này là n, độ phức tạp có thể tăng thành $O(n^2)$.</p>
<p>Worst case của Counting Sort là $O(n + b)$. Nếu $b = O(n)$, độ phức tạp thời gian của Counting Sort sẽ là $O(n)$.</p>
<p><strong>Best case</strong>
Trường hợp tốt nhất xảy ra khi mọi phần tử đều có cùng số chữ số. Độ phức tạp lúc này vẫn là $O(d*(n + b))$.</p>
<p><strong>Average case</strong>
Phân tích dựa vào phân bố của số chữ số, chi tiết ở <a href="https://iq.opengenus.org/time-and-space-complexity-of-radix-sort/">opengenus</a>.</p>
<p><strong>Độ phức tạp không gian</strong>: Thuật toán sử dụng mảng phụ có <code>b</code> phần tử dựa trên cơ số và mảng phụ <code>n</code> phần tử để lưu tạm giá trị. Đôi khi <code>b</code> có thể lớn hơn <code>n</code>, không phải lúc nào <code>n</code> cũng lớn nhất.</p>
<h1 id="complexity">Complexity</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Cases</th>
<th style="text-align:left">Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Best case</td>
<td style="text-align:left">$O(d * (n + b))$</td>
</tr>
<tr>
<td style="text-align:left">Worst case</td>
<td style="text-align:left">$O(d * (n + b))$</td>
</tr>
<tr>
<td style="text-align:left">Average case</td>
<td style="text-align:left">$O(d * (n + b))$</td>
</tr>
</tbody>
</table>
<p>Space Complexity: $O(n + b)$.</p>
<h1 id="code">Code</h1>
<h2 id="modified-counting-sort">Modified Counting Sort</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">int</span> place)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// Cơ số mặc định là 10</span>
    <span class="hljs-keyword">int</span> output[<span class="hljs-built_in">size</span>];
    <span class="hljs-keyword">int</span> count[<span class="hljs-built_in">max</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">max</span>; ++i)
        count[i] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
        count[(<span class="hljs-built_in">array</span>[i] / place) % <span class="hljs-number">10</span>]++;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">max</span>; i++)
        count[i] += count[i - <span class="hljs-number">1</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
        output[count[(<span class="hljs-built_in">array</span>[i] / place) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[i];
        count[(<span class="hljs-built_in">array</span>[i] / place) % <span class="hljs-number">10</span>]--;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
        <span class="hljs-built_in">array</span>[i] = output[i];
}
</div></code></pre>
<h2 id="radix-sort">Radix Sort</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = arr[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)
        <span class="hljs-keyword">if</span> (arr[i] &gt; <span class="hljs-built_in">max</span>)
            <span class="hljs-built_in">max</span> = arr[i];
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = getMax(arr, n);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> place = <span class="hljs-number">1</span>; <span class="hljs-built_in">max</span> / place &gt; <span class="hljs-number">0</span>; place *= <span class="hljs-number">10</span>)
        countingSort(arr, n, place);
}
</div></code></pre>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>