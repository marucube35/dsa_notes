<!DOCTYPE html>
<html>

<head>
  <title>Counting.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>
<link rel="stylesheet" href="file:///g%3A/MATERIAL/Computer/CTDL%20%26%20GT/Note/Sort/md/main.css" type="text/css">
<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="main.css">
<div class="bg">
     <center><h1 class="bigtitle">Counting Sort</h1></center>
</div>
<p>(Hình ảnh và nội dung tham khảo từ <a href="https://www.programiz.com/dsa/counting-sort">programmingquiz</a> và <a href="https://www.journaldev.com/42355/counting-sort-algorithm">journaldev</a>).</p>
<h1 id="idea">Idea</h1>
<p>Counting Sort là thuật toán sắp xếp mảng bằng cách đếm số lần xuất hiện của những phần tử riêng biệt có trong mảng. Số lần đếm được này được lưu trong mảng phụ và thuật toán kết thúc khi ánh xạ các số lần đếm này thành index của mảng.</p>
<p>Các bước thực hiện:</p>
<ol>
<li>Tìm phần tử lớn nhất trong mảng, gọi giá trị này là <code>max</code></li>
</ol>
<img src = "../img/sort26.png">
<ul>
<li>Độ phức tạp thời gian $O(n)$, không gian $O(1)$.</li>
</ul>
<ol start="2">
<li>Khởi tạo một mảng có độ dài <code>max + 1</code> với mọi giá trị đều là 0. Mảng này dùng để lưu các giá trị đếm số lần xuất hiện trong mảng của các phần tử.</li>
</ol>
<img src = "../img/sort27.png">
<ul>
<li>Độ phức tạp thời gian và không gian $O(max)$.</li>
</ul>
<ol start="3">
<li>Tiến hành đếm số lần xuất hiện của giá trị <code>k</code> bất kỳ và cho vào vị trí <code>count[k]</code> của mảng đếm.</li>
</ol>
<img src = "../img/sort28.png">
<ul>
<li>Độ phức tạp thời gian $O(n)$, không gian $O(1)$.</li>
</ul>
<ol start="4">
<li>Thực hiện cộng tích lũy các phần tử trong mảng đếm, phục vụ cho việc ánh xạ sang mảng chính để sắp xếp. Với <code>count[k] = count[k] + count[k - 1]</code>(Tại sao nó phục vụ cho việc ánh xạ ?).</li>
</ol>
<img src = "../img/sort29.png">
<ul>
<li>Độ phức tạp thời gian $O(max)$, không gian $O(1)$.</li>
</ul>
<p>Chú ý rằng giá trị cuối mảng <code>count[]</code> sau khi tính tích lũy luôn là tổng giá trị có trong mảng <code>count[]</code> trước khi tính tích lũy.</p>
<blockquote>
<p>Nếu thực hiện Counting Sort sắp xếp giảm dần, chỉ cần tính tích lũy theo chiều ngược lại.</p>
</blockquote>
<ol start="5">
<li>Tìm vị trí của phần tử mảng, chẳng hạn 4 thông qua mảng đếm và ánh xạ đến đúng vị trí của nó (có trừ cho 1 ?).</li>
</ol>
<img src = "../img/sort30.png">
<ul>
<li>Độ phức tạp thời gian $O(n)$, không gian $O(n)$ (do cần chép qua một mảng phụ).</li>
</ul>
<ol start="6">
<li>Sau khi ánh xạ thì giảm giá trị của <code>count[4]</code> đi 1.</li>
</ol>
<ul>
<li>Độ phức tạp thời gian $O(n)$, không gian $O(1)$.</li>
</ul>
<h1 id="properties">Properties</h1>
<p>Không dựa vào các phép so sánh như các thuật toán thông thường.</p>
<p><strong>Điểm mạnh</strong></p>
<ul>
<li>Stable Sort.</li>
<li>Độ phức tạp tuyến tính rất nhanh.</li>
<li>Giảm không gian phụ nếu khoảng giá trị là nhỏ (nhiều tần số).</li>
</ul>
<p><strong>Điểm yếu</strong></p>
<ul>
<li>Cả độ phức tạp thời gian và không gian tăng đáng kể nếu dữ liệu đầu vào lớn và khoảng giá trị rộng.</li>
<li>Chỉ hoạt động cho các giá trị rời rạc như số nguyên.</li>
<li>Nếu dùng cho số âm thì Complexity và cài đặt đều tăng.</li>
<li>Tiêu tốn nhiều bộ nhớ không cần thiết nếu dữ liệu phân bố thành cụm (chẳng hạn như dữ liệu có 1000 phần tử và có 1000 phần tử giá trị 1. Lúc này mảng đếm có 1000 vị trí nhưng 999 vị trí trong số đó là trống).</li>
</ul>
<h1 id="complexity-analysis">Complexity Analysis</h1>
<p>Như đã ghi chú ở phần Idea, các vòng for ở mỗi có độ phức tạp thời gian lần lượt là:</p>
<ol>
<li>$O(n)$</li>
<li>$O(max)$</li>
<li>$O(n)$</li>
<li>$O(max)$</li>
<li>$O(n)$</li>
<li>$O(n)$</li>
</ol>
<p>Tổng độ phức tạp thời gian là $O(n + max)$. Cả ba cases đều có độ phức tạp thời gian là $O(n + max)$, vì cho dù dữ liệu đầu vào có như thế nào, nó vẫn duyệt qua <code>n + max</code> lần. Điều này cho thấy đây vẫn là một thuật toán không phụ thuộc dãy đầu vào.</p>
<p>Tuy nhiên độ phức tạp không gian là khá cao, $O(max)$.</p>
<h1 id="complexity">Complexity</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Cases</th>
<th style="text-align:left">Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Best case</td>
<td style="text-align:left">$O(n + max)$</td>
</tr>
<tr>
<td style="text-align:left">Worst case</td>
<td style="text-align:left">$O(n + max)$</td>
</tr>
<tr>
<td style="text-align:left">Average case</td>
<td style="text-align:left">$O(n + max)$</td>
</tr>
</tbody>
</table>
<p>Space Complexity: $O(max)$.</p>
<p>với max là giá trị lớn nhất của các phần tử.</p>
<h1 id="code">Code</h1>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span>
</span>{

    <span class="hljs-keyword">int</span> output[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">int</span> count[<span class="hljs-number">10</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">//Đã khởi tạo mảng đếm</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// Tìm phần tử lớn nhất</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] &gt; <span class="hljs-built_in">max</span>)
            <span class="hljs-built_in">max</span> = <span class="hljs-built_in">array</span>[i];
    }

    <span class="hljs-comment">// Đếm tần số xuất hiện của các phần tử</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
    {
        count[<span class="hljs-built_in">array</span>[i]]++;
    }

    <span class="hljs-comment">// Đếm giá trị tích lũy</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">max</span>; i++)
    {
        count[i] += count[i - <span class="hljs-number">1</span>];
    }

    <span class="hljs-comment">// Ánh xạ giá trị qua mảng tạm</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
    {
        output[count[<span class="hljs-built_in">array</span>[i]] - <span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[i];
        count[<span class="hljs-built_in">array</span>[i]]--;
    }

    <span class="hljs-comment">// Chép mảng tạm vào mảng chính</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-built_in">array</span>[i] = output[i];
    }
}
</div></code></pre>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>