<!DOCTYPE html>
<html>

<head>
  <title>Heap.md</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
  
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/*

Atom One Dark by Daniel Gamage
Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

base:    #282c34
mono-1:  #abb2bf
mono-2:  #818896
mono-3:  #5c6370
hue-1:   #56b6c2
hue-2:   #61aeee
hue-3:   #c678dd
hue-4:   #98c379
hue-5:   #e06c75
hue-5-2: #be5046
hue-6:   #d19a66
hue-6-2: #e6c07b

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}

</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
 <script src=""></script>
</head>

<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains("vscode-dark") ||
        document.body.classList.contains("vscode-high-contrast") ?
        "dark" : "default",
    });
  </script>

  <link rel="stylesheet" href="../../main.css">
<div class="bg">
     <center><h1 class="bigtitle">Heap Sort</h1></center>
</div>
<h1 id="idea">Idea</h1>
<p>Thuật toán Heap Sort được chia làm hai phần là xây dựng Max Heap và sắp xếp.</p>
<p><strong>Heap</strong> là cây nhị phân hoàn chỉnh.</p>
<p><strong>Cây nhị phân hoàn chỉnh</strong> là cấu trúc cây nhị phân hoàn hảo nhưng trừ mức cuối, ở mức cuối các node lá dồn hết qua trái càng xa càng tốt.</p>
<img src = "../img/Sort2.png">
<p>Hai phần tử con của một phần tử <strong>a[i]</strong> bất kỳ sẽ nằm ở vị trí <strong>2i + 1</strong> và <strong>2i + 2</strong> (nếu phần tử đầu là 0) hoặc <strong>2i</strong> và <strong>2i + 1</strong> (nếu phần tử đầu là 1). Các phần tử này gọi là các <strong>phần tử liên đới</strong>. Các số đánh trong hình trên chính là vị trí index của các phần tử khi thể hiện dưới dạng mảng. Nếu duyệt cây theo các mức (Level Order Traversal), ta sẽ thu được một danh sách tăng dần các vị trí index từ 1 đến n (hoặc từ 0 đến n – 1).</p>
<p><strong>Vun đống</strong> (Heapify) là một thao tác kiểm tra xem node đang xét có giá trị lớn hơn giá trị của node con nó hay chưa. Chúng ta sẽ hoán vị một phần tử với node con của nó nếu giá trị của node đó bé hơn node con. Và nếu cả hai node con đều lớn hơn, ta sẽ hoán vị với node con lớn nhất.</p>
<p><strong>Max Heap</strong> là một heap sao cho các node đều lớn hơn các node con của nó. Có thể có hai node bằng nhau trong trường hợp Max Heap sử dụng cho thuật toán. Để xây dựng Max Heap, ta sẽ vun đống từ giữa mảng. Ta không cần phải đi xây dựng một cấu trúc cây nhị phân trừu tượng mà sẽ thao tác trực tiếp trên mảng dữ liệu đầu vào.</p>
<p>Giả sử ta cần xây dựng Max Heap từ mảng dưới đây</p>
<img src = "../img/sort3.png">
<p>Phần tử xét vun đống là giữa mảng, có vị trí index là <code>i = int(5 - 1)/2 = 2</code> hoặc <code>i = 6/2 - 1 = 2</code>.</p>
<p>Bước đầu tiên là <strong><code>swap(9,10)</code></strong> vì 10 lớn hơn 9.</p>
<img src = "../img/sort4.png">
<p>Các phần tử bị hoán vị phải được vun đống ở vị trí mà nó hoán vị đến. Việc này để đảm bảo các node luôn có giá trị lớn hơn node con của nó sau khi có sự thay đổi gây ra bởi công việc hoán vị. Ở trên do <code>arr[5]</code> là node lá nên không có gì xảy ra.</p>
<p>Sau khi xét <code>arr[2]</code> thì ta tiếp tục xét <code>arr[1]</code> (cứ thế tiến dần về đầu mảng).</p>
<img src = "../img/sort5.png">
<p>Nhận thấy node này đã được vun đống sẵn rồi nên bỏ qua và xét <code>arr[0]</code>.</p>
<img src = "../img/sort6.png">
<p>Ở đây ta thấy 12 &gt; 10 &gt; 1 nên ta sẽ <strong><code>swap(12,1)</code></strong>. Sau đó xét vun đống ở <code>arr[1]</code>, nơi mà ta vừa thực hiện hoán vị để bảo toàn Max Heap. Tại <code>arr[1]</code> ta thấy 6 &gt; 5 &gt; 1, thực hiện <strong><code>swap(6,1)</code></strong> và xét <code>arr[4]</code> ở bước tiếp theo. Node <code>arr[4]</code> là node lá nên không có gì xảy ra, ta thu được Max Heap hoàn chỉnh.</p>
<p>(Hình ảnh tham khảo từ <a href="https://www.programiz.com/dsa/heap-sort">programmingquiz</a>)</p>
<blockquote>
<p><strong>Tổng quát hóa cho quá trình xây dựng Max Heap</strong>:</p>
</blockquote>
<ul>
<li>Xét vun đống Max Heap tại vị trí giữa mảng. Lý do chọn vị trí này vì các vị trí sau sẽ không tồn tại bất kỳ node con nào.</li>
<li>Khi giá trị của node con lớn hơn node đang xét, hoán vị chúng với nhau. Nếu hai node con đều lớn hơn, chọn node con lớn nhất.</li>
<li>Khi xảy ra hoán vị, cần xét vun đống tại vị trí được hoán vị tới của node đang xét. Ví dụ hoán vị giá trị của node tại vị trí i với vị trí j, thì ta cần phải xét vun đống tại vị trí j.</li>
<li>Lặp lại quá trình xét cho đến phần tử đầu mảng.</li>
</ul>
<blockquote>
<p><strong>Sau khi xây dựng được Max Heap, ta sẽ lặp lại quá trình sắp xếp n lần như sau</strong>:</p>
</blockquote>
<ul>
<li>Hoán vị phần tử đầu với phần tử cuối mảng, sau đó loại bỏ phần tử cuối mảng ra khỏi phạm vi vun đống. Vị trí cuối mảng xem như đã được sắp xếp.</li>
<li>Tiến hành vun đống cho vị trí đầu tiên trong mảng, do các vị trí còn lại đều đã được vun đống.</li>
<li>Lặp lại quá trình này khi chỉ còn một phần tử trong mảng hay nói cách khác là tất cả các phần tử đều đã chuyển đến cuối mảng và được sắp xếp.</li>
</ul>
<h1 id="properties">Properties</h1>
<p>Heap Sort là một thuật toán <strong>cải tiến của Selection Sort</strong>. Nhờ sử dụng cấu trúc Heap mà Heap Sort có số lần so sánh ít hơn Selection, nó chỉ tốn O(nlog(n)) chi phí so sánh.</p>
<p>Heap Sort dựa vào việc so sánh để sắp xếp. Và sự so sánh này trên cấu trúc Heap không bị ảnh hưởng bởi kiểu dữ liệu (int, float, bool, char,...). Ngoài ra, đối với chuỗi ký tự, còn có <strong>Dictionary - based</strong> ?. Ứng dụng trong <strong>Priority Queues</strong> ?.</p>
<p>Ví dụ: &quot;been&quot; &gt; &quot;ant&quot;, &quot;been&quot; &lt; &quot;boy&quot;, &quot;Been&quot; &lt; &quot;been&quot;.</p>
<p><strong>Điểm mạnh</strong></p>
<ul>
<li>Là một thuật toán hiệu quả, sử dụng ít bộ nhớ và ổn định.</li>
<li>Ngoài ra thì cũng có thể tìm top k trong n như Selection Sort.</li>
<li>Có Worst Case tốt hơn Quick Sort.</li>
</ul>
<p><strong>Điểm yếu</strong></p>
<ul>
<li>Là một loại Unstable Sort</li>
<li>Nếu dữ liệu quá lớn hoặc được phân bố ngẫu nhiên thì kém hiệu quả so với Merge Sort hoặc Quick Sort.</li>
<li>Khó cài đặt code.</li>
</ul>
<blockquote>
<p>Khi nào nên sử dụng?</p>
</blockquote>
<ul>
<li>Không gian bộ nhớ bị giới hạn.</li>
</ul>
<h1 id="complexity-analysis">Complexity Analysis</h1>
<p>Ta đã biết chiều cao của cây nhị phân có n nodes là $log_2(n)$. Để vun đống tại node bất kỳ thì thuật toán luôn phải so sánh nó với hai node con. Việc so sánh này sẽ đào sâu đến khi nào chạm node lá, nên chi phí cho việc so sánh sẽ là $O(log_2(n))$.</p>
<p>Trường hợp tốt nhất thì Max Heap đã được xây dựng, không tồn tại bất kỳ phép hoán vị nào, xấu nhất là khi phải đẩy phần tử đang xét vun đống đến tận node lá, tốn $log_2(n)$ lần hoán vị.</p>
<p>Trong bước build Max Heap thì cần xét vun đống cho n/2 phần tử, do đó tổng chi phí trong bước này là $O(\frac{n}{2}*log_2(n)) \sim O(nlog_2(n))$.</p>
<p><em>Thực tế, bước build Max Heap có độ phức tạp là O(n), nhưng do không ảnh hưởng đến tổng độ phức tạp nên không cần đi sâu. Có thể xem ở <a href="https://www.happycoders.eu/algorithms/heapsort/">đây</a>.</em></p>
<p>Ở bước sắp xếp, mỗi lần sắp xếp cũng cần build Max Heap, tốn chi phí $log_2(n)$ để thực hiện phép so sánh, trường hợp xấu nhất thì số phép hoán vị cũng là $log_2(n)$. Và ta thực hiện việc sắp xếp này cho n - 1 phần tử (phần tử cuối cùng mặc định đã được sắp). Do đó chi phí của bước sắp xếp sẽ là $O(nlog_2(n))$.</p>
<p>Do hai bước này thực hiện liền kề nhau, tổng chi phí cho thuật toán là $O(nlog_2(n))$.</p>
<p>Tương tự như Merge Sort, cả ba cases của thuật toán đều có chi phí như nhau là $O(nlog_2(n))$.</p>
<blockquote>
<p>Đối với dữ liệu đã sắp xếp (tăng dần hoặc giảm dần), thì Heap Sort có tốc độ nhanh hơn thông thường.</p>
</blockquote>
<p>Dễ hiểu thì khi dữ liệu giảm dần thì nó đã là Max Heap. Còn trong trường hợp tăng dần thì nó là Min Heap. Do đó chỉ tốn chi phí $O(n)$ để build Heap. Tuy nhiên, chi phí cuối cùng vẫn là $O(nlog_2(n))$.</p>
<p>Mặc dù vậy, máy tính có thể tối ưu thời gian thuật toán của Heap Sort dựa vào <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch prediction</a> nếu dữ liệu đã được sắp xếp. Đại loại là ở mỗi lần thực hiện phép so sánh, kết quả đều giống nhau, nên máy tính có thể dự đoán được kết quả của lần tiếp theo và thực hiện tối ưu. ?</p>
<p>(Tham khảo <a href="https://www.programiz.com/dsa/heap-sort">programmingquiz</a> và <a href="https://www.happycoders.eu/algorithms/heapsort/">happycoders</a>)</p>
<h1 id="complexity">Complexity</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Cases</th>
<th style="text-align:left">Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Best case</td>
<td style="text-align:left">$O(nlog_2(n))$</td>
</tr>
<tr>
<td style="text-align:left">Worst case</td>
<td style="text-align:left">$O(nlog_2(n))$</td>
</tr>
<tr>
<td style="text-align:left">Average case</td>
<td style="text-align:left">$O(nlog_2(n))$</td>
</tr>
</tbody>
</table>
<p>Space Complexity: $O(1)$.</p>
<h1 id="code">Code</h1>
<h2 id="heapify">Heapify</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span>
</span>{
    <span class="hljs-keyword">int</span> largest = i; <span class="hljs-comment">// Khởi tạo phần tử lớn nhất tại i</span>
    <span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; <span class="hljs-comment">// left = 2*i + 1</span>
    <span class="hljs-keyword">int</span> r = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>; <span class="hljs-comment">// right = 2*i + 2</span>

    <span class="hljs-keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])
        largest = l;

    <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])
        largest = r;

    <span class="hljs-keyword">if</span> (largest != i) {
        swap(arr[i], arr[largest]);

        heapify(arr, n, largest);
    }
}
</div></code></pre>
<h2 id="sort">Sort</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-comment">// Xây dựng heap từ giữa mảng đến đầu mảng</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
        heapify(arr, n, i);

    <span class="hljs-comment">// Sắp xếp</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
        <span class="hljs-comment">// Chuyển phần tử root về phần mảng đã được sắp xếp</span>
        swap(arr[<span class="hljs-number">0</span>], arr[i]);

        <span class="hljs-comment">// Tái xây dựng Max Heap ở phần tử root mới</span>
        heapify(arr, i, <span class="hljs-number">0</span>);
    }
}
</div></code></pre>
<h1 id="variants">Variants</h1>
<p>Có một biến thể của Heap Sort gọi là <a href="https://www.happycoders.eu/algorithms/heapsort/">Bottom - Up Heap Sort</a>, được tinh chỉnh phần build Max Heap để giảm số lần so sánh so với Heap Sort thông thường.</p>

</body>

</html>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$', '$']],displayMath: [ ['$$','$$'], ["\\[","\\]"] ],}, 
  messageStyle: "none" ,
});
</script>